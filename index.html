<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Selection Bias &amp; Missing Data Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Selection Bias &amp; Missing Data Challenge</h1>
<p class="subtitle lead">Creating a Statistics Meme: Write Your Own Functions</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="selection-bias-missing-data-challenge" class="level1">
<h1>ğŸ¨ Selection Bias &amp; Missing Data Challenge</h1>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>ğŸ“Š Challenge Overview
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Your Task:</strong> Create a four-panel statistics meme demonstrating selection bias. Youâ€™ll write three Python functions yourself to complete the workflow, then assemble them into a professional meme.</p>
<p><strong>Deliverables:</strong></p>
<ol type="1">
<li>Three Python functions you write yourself:
<ul>
<li><code>step4_create_block_letter.py</code> - Create a block letter â€œSâ€ matching image dimensions</li>
<li><code>step5_create_masked.py</code> - Apply the letter mask to the stippled image</li>
<li><code>create_meme.py</code> - Assemble all components into the four-panel meme</li>
</ul></li>
<li>A complete <code>index.qmd</code> file that uses all functions to generate your meme</li>
<li>Your final statistics meme (as a PNG file) using your own image</li>
</ol>
<p><strong>Key Learning:</strong> This challenge teaches you to write modular Python functions and assemble them into a complete workflow. Youâ€™ll learn to structure code professionally and create a memorable visual representation of selection bias.</p>
<p><strong>Repository Information:</strong></p>
<ul>
<li><strong>Source/Starter File:</strong> Available in the main repository at <a href="https://github.com/flyaflya/selectionBiasChallenge">https://github.com/flyaflya/selectionBiasChallenge</a></li>
<li><strong>Challenge Read Online:</strong> View the challenge instructions at <a href="https://flyaflya.github.io/selectionBiasChallenge">https://flyaflya.github.io/selectionBiasChallenge</a></li>
<li><strong>Your Submission:</strong> Fork this challenge and create your GitHub Pages site at <code>https://[your-username].github.io/selectionBiasChallenge/</code></li>
</ul>
</div>
</div>
<section id="the-problem-visualizing-selection-bias" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-visualizing-selection-bias">The Problem: Visualizing Selection Bias</h2>
<p>Selection bias occurs when observed data isnâ€™t representative of the population. Your meme will demonstrate this concept through visual metaphor:</p>
<ul>
<li><strong>Reality</strong>: Your original image represents the true population</li>
<li><strong>Your Model</strong>: Your stippled image represents your data collection (sampling)</li>
<li><strong>Selection Bias</strong>: A bold letter â€œSâ€ represents a systematic pattern of missing data</li>
<li><strong>Estimate</strong>: Stippled image with â€œSâ€ mask applied shows the biased estimateâ€”what you see when selection bias removes data points in a systematic pattern</li>
</ul>
<p><strong>Key Concept:</strong> Images are simply matricesâ€”2D arrays where each value represents a pixel (0.0 = black, 1.0 = white). Your stippled image is a matrix with black dots (data points) on a white background. Selection bias removes some of these pixels (data points) in a systematic pattern (the â€œSâ€), creating a biased estimate.</p>
<p><strong>Key Insight:</strong> When data is missing in a systematic pattern (not random), your estimates become biased. The â€œSâ€ shape makes it visually obvious that the missing data follows a pattern, just like real selection bias in statistics.</p>
</section>
<section id="example-output" class="level2">
<h2 class="anchored" data-anchor-id="example-output">Example Output</h2>
<p>Hereâ€™s what your final meme should look like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="statistics_meme.png" class="img-fluid figure-img"></p>
<figcaption>Four-panel statistics meme showing Reality (original image), Your Model (stippled version), Selection Bias (letter S), and Estimate (masked stippled image)</figcaption>
</figure>
</div>
<p><strong>Your challenge:</strong> Create a similar meme using your own image, with all code hidden in your <code>index.qmd</code> file. The final output should show only the meme image and a brief 1-3 sentence explanation of how it demonstrates selection bias.</p>
</section>
<section id="getting-started-repository-setup" class="level2">
<h2 class="anchored" data-anchor-id="getting-started-repository-setup">Getting Started: Repository Setup ğŸš€</h2>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>ğŸ“ Repository Setup Instructions
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Step 1:</strong> Fork the starter repository:</p>
<ul>
<li>Navigate to <a href="https://github.com/flyaflya/selectionBiasChallenge">https://github.com/flyaflya/selectionBiasChallenge</a></li>
<li>Fork the repository to your GitHub account (this creates <code>https://github.com/[your-username]/selectionBiasChallenge</code>)</li>
</ul>
<p><strong>Step 2:</strong> Clone your forked repository locally using Cursor (or VS Code)</p>
<p><strong>Step 3:</strong> Set up GitHub Pages:</p>
<ul>
<li>Go to your repository settings (click the â€œSettingsâ€ tab in your GitHub repository)</li>
<li>Scroll down to the â€œPagesâ€ section in the left sidebar</li>
<li>Under â€œSourceâ€, select â€œDeploy from a branchâ€</li>
<li>Choose â€œmainâ€ branch and â€œ/ (root)â€ folder</li>
<li>Click â€œSaveâ€</li>
<li>Your site will be available at: <code>https://[your-username].github.io/selectionBiasChallenge/</code></li>
<li><strong>Note:</strong> It may take a few minutes for the site to become available after enabling Pages</li>
</ul>
<p><strong>Step 4:</strong> Youâ€™re ready to start! Use the <code>index.qmd</code> file as your starting point.</p>
</div>
</div>
</section>
<section id="workflow-overview" class="level2">
<h2 class="anchored" data-anchor-id="workflow-overview">Workflow Overview</h2>
<p>This challenge is organized into discrete steps. Steps 1-3 are provided for you. <strong>You must write Steps 4-6 yourself:</strong></p>
<ol type="1">
<li><strong>Step 1</strong>: Prepare black and white image (provided) âœ…</li>
<li><strong>Step 2</strong>: Create stippled image using blue noise stippling (provided) âœ…</li>
<li><strong>Step 3</strong>: Create tonal analysis (optional refinement step, provided) âœ…</li>
<li><strong>Step 4</strong>: Create block letter â€œSâ€ matching image dimensions (<strong>YOU WRITE THIS</strong>) âš ï¸</li>
<li><strong>Step 5</strong>: Create masked image by applying the letter mask to the stippled image (<strong>YOU WRITE THIS</strong>) âš ï¸</li>
<li><strong>Final</strong>: Assemble all components into the four-panel meme (<strong>YOU WRITE THIS</strong>) âš ï¸</li>
</ol>
<p><strong>Note:</strong> Step 3 is optional but recommended. It helps you understand your imageâ€™s brightness distribution and refine the stippling parameters in Step 2 for better results.</p>
</section>
<section id="understanding-the-workflow" class="level2">
<h2 class="anchored" data-anchor-id="understanding-the-workflow">Understanding the Workflow</h2>
<p>This challenge uses a modular design where each step is implemented as a discrete function in a separate file. This structure provides several benefits:</p>
<section id="modular-design-benefits" class="level3">
<h3 class="anchored" data-anchor-id="modular-design-benefits">Modular Design Benefits</h3>
<ol type="1">
<li><strong>Modularity</strong>: Each step can be modified independently</li>
<li><strong>Reusability</strong>: Functions can be used in other projects</li>
<li><strong>Testability</strong>: Each function can be tested separately</li>
<li><strong>Clarity</strong>: The workflow is easy to understand and follow</li>
<li><strong>Maintainability</strong>: Changes to one step donâ€™t affect others</li>
</ol>
</section>
<section id="function-files" class="level3">
<h3 class="anchored" data-anchor-id="function-files">Function Files</h3>
<p><strong>Steps youâ€™ll use (provided):</strong> - <strong><code>step1_prepare_image.py</code></strong>: Image loading and preprocessing - <strong><code>step2_create_stipple.py</code></strong>: Blue noise stippling algorithm - <strong><code>step3_create_tonal.py</code></strong>: Tonal analysis (optional)</p>
<p><strong>Steps youâ€™ll write:</strong> - <strong><code>step4_create_block_letter.py</code></strong>: Block letter generation âš ï¸ - <strong><code>step5_create_masked.py</code></strong>: Mask application âš ï¸ - <strong><code>create_meme.py</code></strong>: Final assembly and visualization âš ï¸</p>
<p><strong>Supporting functions (provided):</strong> - <strong><code>importance_map.py</code></strong>: Computes importance map for stippling - <strong><code>stippling_functions.py</code></strong>: Core stippling algorithm functions</p>
</section>
</section>
<section id="step-1-prepare-image" class="level2">
<h2 class="anchored" data-anchor-id="step-1-prepare-image">Step 1: Prepare Image</h2>
<p>Load an image, convert to grayscale, and resize to appropriate dimensions while maintaining aspect ratio.</p>
<div id="cell-step1-prepare" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>Resized image from (1488, 1984) to (384, 512) for processing
Final image shape: (384, 512) (should be 2D for grayscale)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="step1-prepare" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step1-prepare-output-2.png" width="588" height="473" class="figure-img"></p>
<figcaption>Original image prepared for processing</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="step-2-create-stippled-image" class="level2">
<h2 class="anchored" data-anchor-id="step-2-create-stippled-image">Step 2: Create Stippled Image</h2>
<p>Generate a blue noise stippling pattern from the prepared image. This creates a pattern of dots that preserves visual information while maintaining good spatial distribution.</p>
<div id="cell-step2-stipple" class="cell" data-message="false" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>Importance map computed
Generating blue noise stippling pattern...
Generated 15728 stipple points
Stipple pattern shape: (384, 512)
Number of stippled points (0.0 values): 15728
Number of background points (1.0 values): 180880</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="step2-stipple" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step2-stipple-output-2.png" width="588" height="473" class="figure-img"></p>
<figcaption>Blue noise stippling pattern</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="step-3-create-tonal-analysis-optional-refinement-step" class="level2">
<h2 class="anchored" data-anchor-id="step-3-create-tonal-analysis-optional-refinement-step">Step 3: Create Tonal Analysis (Optional Refinement Step)</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>ğŸ”§ Optional Refinement Step
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Step 3 is optional</strong> but highly recommended! It creates a box-averaged tonal analysis that helps you understand the brightness distribution across your image. Use this information to <strong>tune the stippling parameters in Step 2</strong> for better results.</p>
<p><strong>How to use it:</strong> - Analyze the tonal distribution to identify key brightness ranges - Adjust <code>extreme_threshold_low</code> and <code>extreme_threshold_high</code> based on your imageâ€™s tone distribution - Tune <code>mid_tone_center</code> to match important features (e.g., skin tones around 0.7) - Refine <code>extreme_downweight</code> based on how much you want to reduce stipples in extreme regions</p>
</div>
</div>
<p>Create a tonal analysis by dividing the image into a grid and computing average brightness in each section. This visualizes the distribution of tones and helps identify which brightness ranges are most important.</p>
<div id="cell-step3-tonal" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Created tonal analysis: grid 16Ã—12
Tonal statistics: mean=0.217, std=0.197
Tone range: [0.004, 0.988]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="step3-tonal" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step3-tonal-output-2.png" width="588" height="473" class="figure-img"></p>
<figcaption>Box-averaged tonal analysis showing brightness distribution</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
ğŸ“Š Tonal Statistics for Parameter Tuning:
  Mean brightness: 0.217
  Standard deviation: 0.197
  Brightness range: [0.004, 0.988]

ğŸ’¡ Tuning Tips:
  - If mean &lt; 0.4: Image is dark, consider lowering extreme_threshold_low
  - If mean &gt; 0.6: Image is light, consider raising extreme_threshold_high
  - If std &gt; 0.2: High contrast, may need stronger extreme_downweight
  - Use mid_tone_center around 0.22 to emphasize average tones</code></pre>
</div>
</div>
</section>
<section id="step-4-create-block-letter-s-your-task" class="level2">
<h2 class="anchored" data-anchor-id="step-4-create-block-letter-s-your-task">Step 4: Create Block Letter â€œSâ€ âš ï¸ <strong>YOUR TASK</strong></h2>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Warning</span>ğŸ¯ Your Challenge: Write <code>step4_create_block_letter.py</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Task:</strong> Create a function <code>create_block_letter_s()</code> that generates a block letter â€œSâ€ matching your image dimensions.</p>
<p><strong>Requirements:</strong> - Function signature: <code>create_block_letter_s(height: int, width: int, letter: str = "S", font_size_ratio: float = 0.9) -&gt; np.ndarray</code> - Returns a 2D numpy array (height Ã— width) with values in [0, 1] - The letter should be black (0.0) on a white background (1.0) - The letter should be centered and scaled appropriately to fit within the image - Use PIL/Pillowâ€™s ImageDraw or similar to render the letter</p>
<p><strong>Hints:</strong> - You can use <code>PIL.Image</code> and <code>PIL.ImageDraw</code> to draw text - Try multiple font paths (e.g., system fonts) if one doesnâ€™t work - Make the letter bold and large enough to be clearly visible - The letter represents the â€œselection biasâ€ pattern in your meme</p>
</div>
</div>
<p><strong>Your code should go in a file called <code>step4_create_block_letter.py</code>.</strong> Once youâ€™ve written it, youâ€™ll use it like this:</p>
<div id="cell-step4-block-letter" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div id="step4-block-letter" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step4-block-letter-output-1.png" width="588" height="473" class="figure-img"></p>
<figcaption>Block letter S representing selection bias</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="step-5-create-masked-image-your-task" class="level2">
<h2 class="anchored" data-anchor-id="step-5-create-masked-image-your-task">Step 5: Create Masked Image âš ï¸ <strong>YOUR TASK</strong></h2>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Warning</span>ğŸ¯ Your Challenge: Write <code>step5_create_masked.py</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Task:</strong> Create a function <code>create_masked_stipple()</code> that applies the block letter mask to the stippled image.</p>
<p><strong>Requirements:</strong> - Function signature: <code>create_masked_stipple(stipple_img: np.ndarray, mask_img: np.ndarray, threshold: float = 0.5) -&gt; np.ndarray</code> - Returns a 2D numpy array with the same shape as the input images - Where the mask is dark (below threshold), remove stipples (set to white/1.0) - Where the mask is light (above threshold), keep the stipples as they are - This creates the â€œbiased estimateâ€ by systematically removing data points</p>
<p><strong>Hints:</strong> - The mask image has values in [0, 1] where 0.0 = black (mask area) and 1.0 = white (keep area) - Use numpy boolean indexing or np.where() to apply the mask - The threshold determines what counts as â€œpart of the maskâ€</p>
</div>
</div>
<p><strong>Your code should go in a file called <code>step5_create_masked.py</code>.</strong> Once youâ€™ve written it, youâ€™ll use it like this:</p>
<div id="cell-step5-masked" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div id="step5-masked" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/step5-masked-output-1.png" width="588" height="473" class="figure-img"></p>
<figcaption>Masked stippled image showing selection bias effect</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="create-the-final-statistics-meme-your-task" class="level2">
<h2 class="anchored" data-anchor-id="create-the-final-statistics-meme-your-task">Create the Final Statistics Meme âš ï¸ <strong>YOUR TASK</strong></h2>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Warning</span>ğŸ¯ Your Challenge: Write <code>create_meme.py</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Task:</strong> Create a function <code>create_statistics_meme()</code> that assembles all four panels into a professional-looking meme.</p>
<p><strong>Requirements:</strong> - Function signature: <code>create_statistics_meme(original_img: np.ndarray, stipple_img: np.ndarray, block_letter_img: np.ndarray, masked_stipple_img: np.ndarray, output_path: str, dpi: int = 150, background_color: str = "white") -&gt; None</code> - Creates a 1Ã—4 layout (four panels side by side) - Each panel should be labeled: â€œRealityâ€, â€œYour Modelâ€, â€œSelection Biasâ€, â€œEstimateâ€ - Save the result as a PNG file - Make it look professional with good spacing, labels, and layout</p>
<p><strong>Hints:</strong> - Use matplotlibâ€™s <code>subplots()</code> or <code>GridSpec</code> to create the layout - Add text labels above or below each panel - Consider adding a border or background color - Use high DPI (150-300) for publication quality - Make sure all images are the same size or handle resizing appropriately</p>
</div>
</div>
<p><strong>Your code should go in a file called <code>create_meme.py</code>.</strong> Once youâ€™ve written it, youâ€™ll use it like this:</p>
<div id="cell-final-meme1" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div id="final-meme1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/final-meme1-output-1.png" class="img-fluid figure-img"></p>
<figcaption>Statistics meme demonstrating selection bias</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="brief-explanation" class="level2">
<h2 class="anchored" data-anchor-id="brief-explanation">Brief Explanation</h2>
<p>This meme shows selection bias by starting with the full party photo as reality, then hiding dots in an S-shaped pattern. Because those missing dots are not random, the final picture (Estimate) no longer matches the real crowd, just like a biased sample doesnâ€™t match the true population.</p>
</section>
<section id="your-final-submission" class="level2">
<h2 class="anchored" data-anchor-id="your-final-submission">Your Final Submission</h2>
<section id="complete-checklist" class="level3">
<h3 class="anchored" data-anchor-id="complete-checklist">Complete Checklist</h3>
<p>To complete this challenge, you must:</p>
<ol type="1">
<li>âœ… <strong>Use Step 1</strong> to prepare your own image (with your own image file)</li>
<li>âœ… <strong>Use Step 2</strong> to generate a stippled image using blue noise stippling</li>
<li>â­ <strong>Optionally use Step 3</strong> to analyze tonal distribution and refine Step 2 parameters (recommended)</li>
<li>âš ï¸ <strong>Write Step 4</strong>: Create <code>step4_create_block_letter.py</code> to generate the block letter â€œSâ€</li>
<li>âš ï¸ <strong>Write Step 5</strong>: Create <code>step5_create_masked.py</code> to apply the mask</li>
<li>âš ï¸ <strong>Write Final Step</strong>: Create <code>create_meme.py</code> to assemble the four-panel meme</li>
<li>âœ… <strong>Create a complete <code>index.qmd</code></strong> that uses all functions (with code hidden)</li>
<li>âœ… <strong>Generate your final meme</strong> using your own image</li>
<li>âœ… <strong>Include a brief explanation</strong> (1-3 sentences) of how the meme demonstrates selection bias</li>
</ol>
</section>
<section id="final-output-requirements" class="level3">
<h3 class="anchored" data-anchor-id="final-output-requirements">Final Output Requirements</h3>
<p><strong>Important:</strong> All code should be hidden (<code>echo: false</code>) in your final <code>index.qmd</code> output. The rendered HTML should show only: - The final meme image - A brief explanation (1-3 sentences) of how it demonstrates selection bias</p>
</section>
<section id="template-for-final-section" class="level3">
<h3 class="anchored" data-anchor-id="template-for-final-section">Template for Final Section</h3>
<p>Hereâ€™s a template for your final section:</p>
</section>
<section id="example-explanation" class="level3">
<h3 class="anchored" data-anchor-id="example-explanation">Example Explanation</h3>
<p>Your explanation should be 1-3 sentences. Hereâ€™s an example:</p>
<blockquote class="blockquote">
<p>This meme demonstrates selection bias by showing how systematic missing data patterns distort our understanding of reality. The original image (Reality) represents the true population, while the stippled version (Your Model) shows our data collection. When selection bias removes data points in a systematic â€œSâ€ pattern, the resulting estimate becomes biased and no longer represents the true population, just as missing data in real-world studies can lead to incorrect conclusions.</p>
</blockquote>
</section>
</section>
<section id="tips-for-success" class="level2">
<h2 class="anchored" data-anchor-id="tips-for-success">Tips for Success</h2>
<ol type="1">
<li><strong>Image Selection</strong>: Choose an image with good contrast for best stippling results</li>
<li><strong>Use Tonal Analysis</strong>: Run Step 3 to understand your imageâ€™s brightness distribution, then refine Step 2 parameters</li>
<li><strong>Function Design</strong>: Write clean, well-documented functions with clear parameter types and return values</li>
<li><strong>Test Incrementally</strong>: Test each function separately before integrating them</li>
<li><strong>Professional Output</strong>: Make your meme look polished with good labels, spacing, and layout</li>
<li><strong>Code Organization</strong>: Keep your functions in separate <code>.py</code> files as specified</li>
<li><strong>Documentation</strong>: Add docstrings to your functions explaining parameters and return values</li>
</ol>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>By completing this challenge, youâ€™ll have created a memorable visual representation of selection bias that demonstrates how systematic missing data patterns can distort our understanding of reality. The skills youâ€™ve practicedâ€”writing modular Python functions, image processing, and creating professional visualizationsâ€”are directly applicable to real-world data analysis projects.</p>
<p>As you work with real datasets, remember the lesson of this meme: when data is missing in a systematic pattern rather than randomly, your estimates become biased. Recognizing and addressing selection bias is crucial for drawing valid conclusions from your data.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>